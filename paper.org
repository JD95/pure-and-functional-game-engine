# org-mode settings
#+STARTUP: indent
#+STARTUP: hidestar

# paper meta 
#+TITLE: A Pure and Functional Game Engine
#+AUTHOR: Jeffrey Dwyer
#+DATE: 09/27/2017
#+OPTIONS: toc:nil

# latex options
#+LATEX_HEADER: \usepackage[margin=0.5in]{geometry}

* Abstract

Some more interesting stuff

* Introduction
** Current State of Game Engines
- Popular engines like Unity break down into several modules, artifical intelligence, physics, scripting, input, multimedia, and networking cite:messaoudi_dissecting_2015. 
** The End of Moore's Law
** The Rise of Multi-core Processing
** Goal of 60 fps
* Game Engine Architecture
- There are two portions of the engine which are completely serial, the construction of the render tree and iteraction resolution cite:tulip_multi-threaded_2006.
- Several features which can be parallelized are: interpolation of animations, the application of lighting and textures, sound source contributions, rendering frames between updates cite:tulip_multi-threaded_2006.
- Certain modules within the engine serve only to produce or consume data. Several producers are user input and networking. Several consumers are sound and rendering cite:tulip_multi-threaded_2006.
** Game Loop
** Minimizing Work
- Even in fully featured and popular game engines like Unity, most of the work is done in the rendering modules of the engine cite:messaoudi_dissecting_2015.  
** Minimizing Allocations
** Maximizing Spatial Locality
* Parallelization For Free
- There are several considerations to be taken when parallelizing the engine. First, the number of threads should be minimized to the number of cores available. Second, the creation and descrution of threads should be avoided while processing data. Third, the synchonization should be minimzed. And finally, the workload should be balanced across threads cite:tulip_multi-threaded_2006.
- One of the main concerns in concurrent programming is the possibility of dead locks, a situation in which many seperate processes are waiting on eachother in a cycle for some resource. One technique to avoid dead locks is software transactional memory (STM). This methodology performs small, tasks which either complete successfuly or are rolled back. Atomicity, a name given to the previous features, is what allows for locking to be avoided all together using STM. Lock free data structures using STM are faster than their locking counterparts  cite:discolo_lock_2006.
- The Intel white paper suggests breaking the code up into different managers and distributing tasks to various task managers on different treads. Tasks are created via messages between the different threads cite:andrews_designing_2009. 
** Parallel Engine Components 
** Parallelism in Haskell
** Haskell STM
* Feasability of design in large scale applications.
- Arrowized FRP can change how signals are processed without space leaks  cite:czaplicki_asynchronous_2013.
- In their formulation of FRP, changes do not propogate unless a discrete event occurs cite:czaplicki_asynchronous_2013. This change, while unfaithful to the original semantics of FRP is much more suited for graphical interfaces due to that face that the user can only interact with the system in discrete ways. It goes without saying that the interaction model between the user and a game engine are the same as that of a normal graphical application, however this formulation can also extend to all types of events within the reactive system.
- In his reformulation of the original FRP semantics, Elliott introduced the idea of reactive values and push-pull semantics to address the same performance issues. Reactive values allow for changes to certain values to be propogated or pushed through the system, leaving pull based updates to time dependent events. This change removes much of the wasteful updates caused in the original formulation cite:elliott_push-pull_2009.
** Reactive Programming
*** Programming With Time 
*** Push - Pull frp
- Perhaps using the pull option to prevent physics from being calculated for that object? Although, I'd have to figure out how to "remove" that object from the physics consideration, but then again, we'd have to build up the quad tree anyways, so not including it in that calculation might be possible.
*** Scene Updates Through FRP
*** Message Passing
** Haxl
*** Uses at facebook
*** Data Sources
*** Request caching
** Fraxl
*** Generalization of Haxl
*** Using previous state as a data source
* Making it Efficent
- Generational garbage collection favors young objects cite:marlow_parallel_2008. 
- Fusion allows for various intermediate data structures to be eliminated during compilation cite:bernardy_composable_2016.
- Using recursion schemes as the basic building block of code allows for high fusability as they use a consumer producer mode. Anamorphisms are recursive producers and catamorphisms are recursive consumers cite:meijer_functional_1991.
- Immutability allows for efficent checking of garbage in large structures cite:marlow_parallel_2008.
** Analyzing Time Complexity of Functional Data Structures
*** Differences from normal data structures
*** lazieness
*** purity
*** methods
*** several useful datastructures for the game
** Garbage Collection in Haskell
*** Reiterate problems with GC
*** How to optimize for low GC in Haskell
** Fusion
*** Consumer - Producer pattern
*** Recursion Schemes
*** Application to engine
** Compact Regions
- Immutable data with no outgoing pointers is best suited for networking and serialization  cite:yang_efficient_2015.
- Compact regions can be written directly to files or sent over the network. The internal pointers need simply be offset to match their new spot in memory  cite:yang_efficient_2015.
- The property of no outgoing pointers means that only the top level reference to the structure need be checked during garbage collection  cite:yang_efficient_2015.
*** What are compact regions
*** How they're used
*** Application to engine
** Linear Types
*** Linear Logic
*** Implications on GC
*** Application to engine
* Conclusions

bibliography:refs.bib
bibliographystyle:unsrt
