# org-mode settings
#+STARTUP: indent
#+STARTUP: hidestar

# paper meta 
#+TITLE: A Pure and Functional Game Engine
#+AUTHOR: Jeffrey Dwyer
#+DATE: 09/27/2017
#+OPTIONS: toc:nil

# latex options
#+LATEX_HEADER: \usepackage[margin=0.5in]{geometry}

* Abstract
* Introduction
** Current State of Game Engines
** Goal of 60 fps
* Game Engine Architecture
- There are two portions of the engine which are completely serial, the construction of the render tree and iteraction resolution cite:tulip_multi-threaded_2006.
- Several features which can be parallelized are: interpolation of animations, the application of lighting and textures, sound source contributions, rendering frames between updates cite:tulip_multi-threaded_2006.
- Certain modules within the engine serve only to produce or consume data. Several producers are user input and networking. Several consumers are sound and rendering cite:tulip_multi-threaded_2006.
** Game Loop
** Rendering
** Physics
** Input
** Scenes
* Parallelization For Free
- There are several considerations to be taken when parallelizing the engine. First, the number of threads should be minimized to the number of cores available. Second, the creation and descrution of threads should be avoided while processing data. Third, the synchonization should be minimzed. And finally, the workload should be balanced across threads cite:tulip_multi-threaded_2006.
** Parallelism in Haskell
** Haskell STM
** How design can take advantage of parallelism
* Scaling the design 
** Reactive Programming
*** Preventing unnecessary computations with Push - Pull frp
- Perhaps using the pull option to prevent physics from being calculated for that object? Although, I'd have to figure out how to "remove" that object from the physics consideration, but then again, we'd have to build up the quad tree anyways, so not including it in that calculation might be possible.
** Haxl
*** Uses at facebook
*** Data Sources
*** Request caching
** Fraxl
*** Generalization of Haxl
*** Using previous state as a data source
* Making it Efficent
- Generational garbage collection favors young objects cite:sansom_generational_1993.
** Analyzing Time Complexity of Functional Data Structures
*** Differences from normal data structures
*** lazieness
*** purity
*** methods
*** several useful datastructures for the game
** Garbage Collection in Haskell
*** Reiterate problems with GC
*** How to optimize for low GC in Haskell
** Fusion
*** Consumer - Producer pattern
*** Recursion Schemes
*** Application to engine
** Compact Regions
*** What are compact regions
*** How they're used
*** Application to engine
** Linear Types
*** Linear Logic
*** Implications on GC
*** Application to engine
* Conclusions

bibliography:refs.bib
bibliographystyle:unsrt
