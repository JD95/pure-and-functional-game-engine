% Created 2017-09-27 Wed 16:22
\documentclass[11pt]{article}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\author{Jeffrey Dwyer}
\date{09/27/2017}
\title{Summary of Motivation}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 25.2.1 (Org mode 8.2.10)}}
\begin{document}

\maketitle
Most programs, as they are written today, are constructed as a series of steps to be taken by the computer, one at a time, in that order. Since the rise of computing, this style has been dominant in part due to the famous "Moore's Law" which predicted a doubling of computing power every year. This trend stayed true until fairly recently, when researchers began realizing that processing power of single core devices was reaching their maximum. The modern strategy is now to simply add more cores to computers, allowing programs to do many tasks in parallel. However, this new capability is not readily available to all programs.

One of the fundamental steps in a computer program is changing a value in some way. Whether it is adding one to a counter, changing a letter in a word, or setting some truth value, programs are infested with instructions to change data. Free range mutation of information makes parallel processing challenging, if not impossible in some cases. If tasks may freely alter the data of other tasks, then data may become corrupted, or a task may become confused and halt, never actually finishing it's work.

A prime example of software which has much to gain from parallelization but is at the same time highly resistant to this change would be a game engine. These programs are the foundation on which games are built and significantly reduce the work developers need to do in order to ship their products. For the past thirty years, game engines have been optimized to be able to simulate physics, run artificial intelligence, animate characters, and render the thousands of entities within a scene in only sixteen milliseconds. However, most of the optimizations to make such performance possible has been designed for a single processing unit without any parallelization in mind. To gain speed, engines are filled with data mutation at every turn, in part for convince yet some of the speed is only possible by changing data in specific ways. With the slowing of speed increases for single cores, game engines are also reaching their limit.

It seems strange to imagine how engines could be reworked to be parallel at all, but there are those who would claim that game engines have many components which are naturally parallel tasks \cite{tulip_multi-threaded_2006}. For example, the artificial intelligence calculations can be done for each unit within a game whiteout much concern for the results of the others. Communication with the network or loading files from the hard disk can be done separately from the main game loop. As most of the popular game engines stand though, the changes needed to implement these parallel features would be enormously complex \cite{gajinov_case_2014}. It is more practical to instead attempt to design such an engine from the ground up, with parallelization in mind from the start.

The creation of such a system is not only necessary for the gaming industry to continue its pace of bigger and better releases, but it also has implications outside of the field. Games are primarily a form of entertainment, yet it is often that the technology used to gain maximal performance in game play has applications to other fields. This multi billion dollar industry brings together many disciplines and drives research into compelling areas such as physics simulations and artificial intelligence. Many of the new techniques in the afore mentioned fields were developed as a direct result of advances in game performance. To continue the push of innovation, this challenge must be undertaken. 

\bibliography{refs}
\bibliographystyle{unsrt}
% Emacs 25.2.1 (Org mode 8.2.10)
\end{document}
